package bip39

import (
	"crypto/rand"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/binary"
	"fmt"
	"golang.org/x/crypto/pbkdf2"
	"math/big"
	"strings"
)

// EntropySize bip39 compliant entropy sizes
type EntropySize int

const (
	EntropySize128 EntropySize = 128
	EntropySize160 EntropySize = 160
	EntropySize192 EntropySize = 192
	EntropySize224 EntropySize = 224
	EntropySize256 EntropySize = 256
)

// NewEntropy generates random entropy bytes
func NewEntropy(size EntropySize) ([]byte, error) {
	entropy := make([]byte, size/8)
	if _, err := rand.Read(entropy); err != nil {
		return nil, err
	}
	return entropy, nil
}

// NewMnemonic returns a string of the mnemonic words for the given entropy.
// If the provided entropy is invalid returns an error.
func NewMnemonic(entropy []byte, wordList []string) (string, error) {
	// Compute lengths
	entropyBitLength := len(entropy) * 8
	checksumBitLength := entropyBitLength / 32
	sentenceLength := (entropyBitLength + checksumBitLength) / 11

	// Validate entropy size is supported.
	err := validateEntropyBitSize(entropyBitLength)
	if err != nil {
		return "", err
	}

	// Add checksum to entropy.
	entropy = addChecksum(entropy)

	// Break entropy up into sentenceLength chunks of 11 bits.
	// For each word AND mask the rightmost 11 bits & find the word at that idx.
	// Then bitshift entropy 11 bits right and repeat.
	// Add to the last empty slot so we can work with LSBs instead of MSB.

	// Entropy as an int so we can bitmask without worrying about bytes slices.
	entropyInt := new(big.Int).SetBytes(entropy)

	// Slice to hold words in.
	words := make([]string, sentenceLength)

	// Throw away big.Int for AND masking.
	word := big.NewInt(0)

	if err != nil {
		return "", err
	}

	for i := sentenceLength - 1; i >= 0; i-- {
		// Get 11 right most bits and bitshift 11 to the right for next time.
		word.And(entropyInt, last11BitsMask)
		entropyInt.Div(entropyInt, shift11BitsMask)

		// Get the bytes representing the 11 bits as a 2 byte slice.
		wordBytes := padByteSlice(word.Bytes(), 2)

		// Convert bytes to an index and add that word to the list.
		words[i] = wordList[binary.BigEndian.Uint16(wordBytes)]
	}

	return strings.Join(words, " "), nil
}

// NewSeed creates a hashed seed output given a provided string and password.
func NewSeed(mnemonic string, password string) []byte {
	return pbkdf2.Key([]byte(mnemonic), []byte("mnemonic"+password), 2048, 64, sha512.New)
}

// validateEntropyBitSize ensures that entropy size matches bip39 standard
func validateEntropyBitSize(bitSize int) error {
	if (bitSize%32) != 0 || bitSize < 128 || bitSize > 256 {
		return newError(ErrorCodeInvalidEntropyLen)
	}

	return nil
}

// addChecksum add checksum to entropy data
func addChecksum(entropy []byte) []byte {
	checkSum := sha256.Sum256(entropy)
	firstChecksumByte := checkSum[0]

	// checksum length is entropyLen / 32, len() is in bytes (8) so we divide by 4
	checksumBitLength := uint(len(entropy) / 4)

	// For each bit of check sum we want we shift the data one the left
	// and then set the (new) right most bit equal to checksum bit at that index
	// staring from the left
	dataBigInt := new(big.Int).SetBytes(entropy)

	for i := uint(0); i < checksumBitLength; i++ {
		// Bitshift 1 left
		dataBigInt.Mul(dataBigInt, bigTwo)

		// Set rightmost bit if leftmost checksum bit is set
		if firstChecksumByte&(1<<(7-i)) > 0 {
			dataBigInt.Or(dataBigInt, bigOne)
		}
	}

	return dataBigInt.Bytes()
}

// padByteSlice returns a byte slice of the given size with contents of the
// given slice left padded and any empty spaces filled with 0's.
func padByteSlice(slice []byte, length int) []byte {
	offset := length - len(slice)
	if offset <= 0 {
		return slice
	}

	newSlice := make([]byte, length)
	copy(newSlice[offset:], slice)

	return newSlice
}

// MARK: - Validation

// IsMnemonicValid attempts to verify that the provided mnemonic is valid.
// Validity is determined by both the number of words being appropriate,
// and that all the words in the mnemonic are present in the word list.
func IsMnemonicValid(mnemonic string, wordMap map[string]int) bool {
	_, err := EntropyFromMnemonic(mnemonic, wordMap)
	return err == nil
}

// EntropyFromMnemonic takes a mnemonic generated by this library,
// and returns the input entropy used to generate the given mnemonic.
// An error is returned if the given mnemonic is invalid.
func EntropyFromMnemonic(mnemonic string, wordMap map[string]int) ([]byte, error) {
	mnemonicWords := strings.Fields(mnemonic)

	if !isValidWordsCount(mnemonicWords) {
		return nil, newError(ErrorCodeInvalidWordCount)
	}

	var wordBytes [2]byte
	b := big.NewInt(0)

	for _, v := range mnemonicWords {
		index, found := wordMap[v]
		if !found {
			// TODO: Return invalid word
			return nil, newErrorWithInvalidWord(v)
		}

		binary.BigEndian.PutUint16(wordBytes[:], uint16(index))
		b.Mul(b, shift11BitsMask)
		b.Or(b, big.NewInt(0).SetBytes(wordBytes[:]))
	}

	// Build and add the checksum to the big.Int.
	checksum := big.NewInt(0)
	checksumMask := wordLengthChecksumMasksMapping[len(mnemonicWords)]
	checksum = checksum.And(b, checksumMask)

	b.Div(b, big.NewInt(0).Add(checksumMask, bigOne))

	// The entropy is the underlying bytes of the big.Int. Any upper bytes of
	// all 0's are not returned so we pad the beginning of the slice with empty
	// bytes if necessary.
	entropy := b.Bytes()
	entropy = padByteSlice(entropy, len(mnemonicWords)/3*4)

	// Generate the checksum and compare with the one we got from the mnemonic.
	entropyChecksumBytes := sha256.Sum256(entropy)
	entropyChecksum := big.NewInt(int64(entropyChecksumBytes[0]))

	if l := len(mnemonicWords); l != 24 {
		checksumShift := wordLengthChecksumShiftMapping[l]
		entropyChecksum.Div(entropyChecksum, checksumShift)
	}

	if checksum.Cmp(entropyChecksum) != 0 {
		return nil, newError(ErrorCodeInvalidCheckSum)
	}

	return entropy, nil
}

func isValidWordsCount(words []string) bool {
	wordsLen := len(words)
	return !(wordsLen%3 != 0 || wordsLen < 12 || wordsLen > 24)
}

var (
	// Some bitwise operands for working with `big.Int`s.
	last11BitsMask  = big.NewInt(2047)
	shift11BitsMask = big.NewInt(2048)
	bigOne          = big.NewInt(1)
	bigTwo          = big.NewInt(2)

	// wordLengthChecksumMasksMapping is used to isolate the checksum bits from
	// the entropy+checksum byte array.
	wordLengthChecksumMasksMapping = map[int]*big.Int{
		12: big.NewInt(15),
		15: big.NewInt(31),
		18: big.NewInt(63),
		21: big.NewInt(127),
		24: big.NewInt(255),
	}

	// wordLengthChecksumShiftMapping is used to lookup the number of operand
	// for shifting bits to handle checksums.
	wordLengthChecksumShiftMapping = map[int]*big.Int{
		12: big.NewInt(16),
		15: big.NewInt(8),
		18: big.NewInt(4),
		21: big.NewInt(2),
	}
)

// MARK: - Errors

// ErrorCode for easier compatibility with `gomobile`
type ErrorCode int

const (
	ErrorCodeInvalidWordCount = iota
	ErrorCodeInvalidWord
	ErrorCodeInvalidEntropyLen
	ErrorCodeInvalidCheckSum
)

type Error struct {
	code ErrorCode
	word string
}

func newError(code ErrorCode) *Error {
	return &Error{code, ""}
}

func newErrorWithInvalidWord(word string) *Error {
	return &Error{ErrorCodeInvalidWord, word}
}

func (e *Error) Code() ErrorCode {
	return e.code
}

func (e *Error) InvalidWord() string {
	return ""
}

func (e *Error) Error() string {
	switch e.code {
	case ErrorCodeInvalidWordCount:
		return "Invalid word count"
	case ErrorCodeInvalidWord:
		return fmt.Sprintf("Invalid word at %v", e.InvalidWord())
	case ErrorCodeInvalidEntropyLen:
		return "Invalid entropy length"
	case ErrorCodeInvalidCheckSum:
		return "Invalid checksum"
	}
	return "Unknown error"
}
